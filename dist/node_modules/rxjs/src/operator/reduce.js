import { Observable } from '../Observable';
import { reduce as higherOrderReduce } from '../operators/reduce';
this;
Observable < T > , accumulator;
    (acc, value, index) => T, seed ?  : T;
Observable();
this;
Observable < T > , accumulator;
    (acc, value, index) => T[], seed;
T[];
Observable();
this;
Observable < T > , accumulator;
    (acc, value, index) => R, seed;
R;
Observable();
this;
Observable < T > , accumulator;
    (acc, value, index) => R, seed ?  : R;
Observable < R > {
    // providing a seed of `undefined` *should* be valid and trigger
    // hasSeed! so don't use `seed !== undefined` checks!
    // For this reason, we have to check it here at the original call site
    // otherwise inside Operator/Subscriber we won't know if `undefined`
    // means they didn't provide anything or if they literally provided `undefined`
    if(arguments, length =  >= 2) {
        return higherOrderReduce(accumulator, seed)(this);
    },
    return: higherOrderReduce(accumulator)(this)
};
