import { AsyncAction } from './AsyncAction';
import { Subscription } from '../Subscription';
import { AsyncScheduler } from './AsyncScheduler';
export class VirtualTimeScheduler extends AsyncScheduler {
    constructor(SchedulerAction = VirtualAction, maxFrames = Number.POSITIVE_INFINITY) {
        super(SchedulerAction, () => this.frame);
        this.maxFrames = maxFrames;
        this.frame = 0;
        this.index = -1;
    }
    /**
     * Prompt the Scheduler to execute all of its queued actions, therefore
     * clearing its queue.
     * @return {void}
     */
    flush() {
        const { actions, maxFrames } = this;
        let error, action;
        while ((action = actions.shift()) && (this.frame = action.delay) <= maxFrames) {
            if (error = action.execute(action.state, action.delay)) {
                break;
            }
        }
        if (error) {
            while (action = actions.shift()) {
                action.unsubscribe();
            }
            throw error;
        }
    }
}
VirtualTimeScheduler.frameTimeFactor = 10;
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
export class VirtualAction extends AsyncAction {
    constructor(...args) {
        super(...args);
        this.active = true;
    }
}
void ,
    protected;
index: number = scheduler.index += 1;
{
    super(scheduler, work);
    this.index = scheduler.index = index;
}
schedule(state ?  : T, delay, number = 0);
Subscription;
{
    if (!this.id) {
        return super.schedule(state, delay);
    }
    this.active = false;
    // If an action is rescheduled, we save allocations by mutating its state,
    // pushing it to the end of the scheduler queue, and recycling the action.
    // But since the VirtualTimeScheduler is used for testing, VirtualActions
    // must be immutable so they can be inspected later.
    const action = new VirtualAction(this.scheduler, this.work);
    this.add(action);
    return action.schedule(state, delay);
}
requestAsyncId(scheduler, VirtualTimeScheduler, id ?  : any, delay, number = 0);
any;
{
    this.delay = scheduler.frame + delay;
    const { actions } = scheduler;
    actions.push(this);
    actions.sort(VirtualAction.sortActions);
    return true;
}
recycleAsyncId(scheduler, VirtualTimeScheduler, id ?  : any, delay, number = 0);
any;
{
    return undefined;
}
_execute(state, T, delay, number);
any;
{
    if (this.active === true) {
        return super._execute(state, delay);
    }
}
sortActions(a, VirtualAction < T > , b, VirtualAction(), {
    if(a, delay =  === b.delay) {
        if (a.index === b.index) {
            return 0;
        }
        else if (a.index > b.index) {
            return 1;
        }
        else {
            return -1;
        }
    }, else: , if(a, delay =  > b.delay) {
        return 1;
    }, else: {
        return: -1
    }
});
